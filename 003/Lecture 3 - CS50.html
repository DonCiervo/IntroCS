<!DOCTYPE html>
<!-- saved from url=(0041)https://cs50.harvard.edu/college/notes/3/ -->
<html lang="en-us" class="gr__cs50_harvard_edu"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta property="og:description" content="Introduction to the intellectual enterprises of computer science and the art of programming. This course teaches students how to think algorithmically and solve problems efficiently. Topics include abstraction, algorithms, data structures, encapsulation, resource management, security, and software engineering. Languages include C, Python, and SQL plus students‚Äô choice of: HTML, CSS, and JavaScript (for web development); Java or Swift (for mobile app development); or Lua (for game development). Problem sets inspired by the arts, humanities, social sciences, and sciences. Course culminates in a final project. Designed for concentrators and non-concentrators alike, with or without prior programming experience. Two thirds of CS50 students have never taken CS before. Among the overarching goals of this course are to inspire students to explore unfamiliar waters, without fear of failure, create an intensive, shared experience, accessible to all students, and build community among students.">

<meta property="og:image" content=""><meta property="og:title" content="Lecture 3 - CS50">

<meta property="og:url" content=""><link href="https://cs50.harvard.edu/college/favicon.ico?1573000452" rel="icon">

<!-- https://fontawesome.com/how-to-use/on-the-web/referencing-icons/basic-use -->
<link href="./Lecture 3 - CS50_files/all.min.css" rel="stylesheet">

<link href="./Lecture 3 - CS50_files/page.css" rel="stylesheet">

<!-- http://getbootstrap.com/docs/4.3/getting-started/introduction/ -->
<script src="./Lecture 3 - CS50_files/jquery.min.js"></script>
<script src="./Lecture 3 - CS50_files/popper.min.js"></script>
<script src="./Lecture 3 - CS50_files/bootstrap.min.js"></script>

<!-- https://github.com/pellepim/jstimezonedetect -->
<script src="./Lecture 3 - CS50_files/jstz.min.js"></script>

<script src="./Lecture 3 - CS50_files/jekyll-theme-cs50.js"></script>

<title>Lecture 3 - CS50</title>
</head>

    <body data-gr-c-s-loaded="true">

        <div class="container-fluid">

            <div class="row">

                <aside class="col-md">
 
                    <header><h1 data-id="this-is-cs50"><a href="https://cs50.harvard.edu/college/">This is CS50</a></h1>

<p><a href="https://www.harvard.edu/">Harvard University</a><br>
Fall 2019</p></header>

                    <button aria-controls="nav" aria-expanded="false" class="btn btn-sm collapsed d-md-none" data-target="aside &gt; nav" data-toggle="collapse">Menu</button>

                    <nav class="collapse d-md-block"><hr>

<ul class="fa-ul">
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://cs50.harvard.edu/college/weeks/0/">Week 0</a> Scratch</li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://cs50.harvard.edu/college/weeks/1/">Week 1</a> C</li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://cs50.harvard.edu/college/weeks/2/">Week 2</a> Arrays</li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://cs50.harvard.edu/college/weeks/3/">Week 3</a> Algorithms</li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://cs50.harvard.edu/college/weeks/4/">Week 4</a> Memory</li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://cs50.harvard.edu/college/weeks/5/">Week 5</a> Data Structures</li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://cs50.harvard.edu/college/weeks/6/">Week 6</a> Python <em class="text-white">üêç</em></li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://cs50.harvard.edu/college/weeks/7/">Week 7</a> SQL</li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>
    <p><a href="https://cs50.harvard.edu/college/weeks/8/">Week 8</a> Information</p>
  </li>
</ul>

<ul class="fa-ul">
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://cs50.harvard.edu/college/tracks/">Tracks</a></li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://cs50.harvard.edu/college/project/">Final Project</a></li>
</ul>

<hr>

<ul class="fa-ul">
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://cs50.harvard.edu/ed">Q&amp;A</a></li>
</ul>

<hr>

<ul class="fa-ul">
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://docs.google.com/forms/d/e/1FAIpQLSdtV5QRs_gS0cZ77GPHQSYgtvOTWc5jS_i0Oms2Hqd5q3PuWw/viewform?usp=pp_url&amp;entry.987014883=COMPSCI+50+at+Harvard+College">Anonymous Feedback</a></li>
</ul>

<hr>

<ul class="fa-ul">
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://cs50.harvard.edu/college/faqs/">FAQs</a></li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://open.spotify.com/user/arubery/playlist/7juFEfDDYC3DBCoRq7W9Cp">Music</a></li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://cs50.harvard.edu/college/hours/">Office Hours</a></li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://cs50.harvard.edu/college/photos/">Photos</a></li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://cs50.harvard.edu/college/sections/">Sections</a></li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://cs50.harvard.edu/college/staff/">Staff</a></li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://cs50.harvard.edu/college/supersections/">Supersections</a></li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://cs50.harvard.edu/college/syllabus/">Syllabus</a></li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://cs50.harvard.edu/college/test/">Test</a></li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://cs50.harvard.edu/college/tutorials/">Tutorials</a></li>
</ul>

<hr>

<ul class="small fa-ul">
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://ide.cs50.io/">CS50 IDE</a></li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://sandbox.cs50.io/">CS50 Sandbox</a></li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://sqlitebrowser.org/">DB Browser for SQLite</a></li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://harvard.cs50.me/">Gradebook</a></li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://man.cs50.io/">Manual Pages</a></li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://docs.python.org/3.7/search.html">Python Documentation</a></li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://stackoverflow.com/search">Stack Overflow</a></li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><a href="https://cs50.readthedocs.io/style/c/">Style Guide</a></li>
</ul>

<hr>

<p style="font-size: initial">With <a href="https://cs50.harvard.edu/college/thanks/">thanks</a> to CS50‚Äôs alumni and friends</p></nav>

                    <footer></footer>

                </aside>

                <main class="col-md markdown-body" style="margin-bottom: 0px;">

                    <h1 class="no_toc" id="lecture-3"><a data-id="" href="https://cs50.harvard.edu/college/notes/3/#lecture-3">Lecture 3</a></h1>

<ul id="markdown-toc">
  <li><a href="https://cs50.harvard.edu/college/notes/3/#searching" id="markdown-toc-searching">Searching</a></li>
  <li><a href="https://cs50.harvard.edu/college/notes/3/#big-o" id="markdown-toc-big-o">Big O</a></li>
  <li><a href="https://cs50.harvard.edu/college/notes/3/#linear-search" id="markdown-toc-linear-search">Linear search</a></li>
  <li><a href="https://cs50.harvard.edu/college/notes/3/#structs" id="markdown-toc-structs">Structs</a></li>
  <li><a href="https://cs50.harvard.edu/college/notes/3/#sorting" id="markdown-toc-sorting">Sorting</a></li>
  <li><a href="https://cs50.harvard.edu/college/notes/3/#selection-sort" id="markdown-toc-selection-sort">Selection sort</a></li>
  <li><a href="https://cs50.harvard.edu/college/notes/3/#recursion" id="markdown-toc-recursion">Recursion</a></li>
  <li><a href="https://cs50.harvard.edu/college/notes/3/#merge-sort" id="markdown-toc-merge-sort">Merge sort</a></li>
</ul>

<h2 id="searching"><a data-id="" href="https://cs50.harvard.edu/college/notes/3/#searching">Searching</a></h2>

<ul class="fa-ul">
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>Last time, we talked about memory in a computer, or RAM, and how our data can be stored as individual variables or as arrays of many items, or elements.</li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>We can think of an array with a number of items as a row of lockers, where a computer can only open one locker to look at an item, one at a time.</li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>For example, if we want to check whether a number is in an array, with an algorithm that took in an array as input and produce a boolean as a result, we might:
    <ul class="fa-ul">
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>look in each locker, or at each element, one at a time, from the beginning to the end.
        <ul class="fa-ul">
          <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>This is called <strong>linear search</strong>, where we move in a line, since our array isn‚Äôt sorted.</li>
        </ul>
      </li>
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>start in the middle and move left or right depending on what we‚Äôre looking for, if our array of items is sorted.
        <ul class="fa-ul">
          <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>This is called <strong>binary search</strong>, since we can divide our problem in two with each step, like what David did with the phone book in week 0.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>We might write pseudocode for linear search with:
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>For i from 0 to n‚Äì1
    If i'th element is 50
        Return true
Return false
</code></pre></div>    </div>
    <ul class="fa-ul">
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>We can label each of <code class="highlighter-rouge">n</code> lockers from <code class="highlighter-rouge">0</code> to <code class="highlighter-rouge">n‚Äì1</code>, and check each of them in order.</li>
    </ul>
  </li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>For binary search, our algorithm might look like:
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>If no items
    Return false
If middle item is 50
    Return true
Else if 50 &lt; middle item
    Search left half
Else if 50 &gt; middle item
    Search right half
</code></pre></div>    </div>
    <ul class="fa-ul">
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>Eventually, we won‚Äôt have any parts of the array left (if the item we want wasn‚Äôt in it), so we can return <code class="highlighter-rouge">false</code>.</li>
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>Otherwise, we can search each half depending on the value of the middle item.</li>
    </ul>
  </li>
</ul>

<h2 id="big-o"><a data-id="" href="https://cs50.harvard.edu/college/notes/3/#big-o">Big O</a></h2>

<ul class="fa-ul">
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>In week 0, we saw different types of algorithms and their running times:
<img src="./Lecture 3 - CS50_files/running_time.png" alt="chart with: &quot;size of problem&quot; as x‚Äìaxis; &quot;time to solve&quot; as y‚Äìaxis; red, steep straight line from origin to top of graph labeled &quot;n&quot;; yellow, less steep straight line from origin to top of graph labeled &quot;n/2&quot;; green, curved line that gets less and less steep from origin to right of graph labeled &quot;log_2 n&quot;"></li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>The more formal way to describe this is with big <em>O</em> notation, which we can think of as ‚Äúon the order of‚Äù. For example, if our algorithm is linear search, it will take approximately <em>O</em>(<em>n</em>) steps, ‚Äúon the order of <em>n</em>‚Äù. In fact, even an algorithm that looks at two items at a time and takes <em>n</em>/2 steps has <em>O</em>(<em>n</em>). This is because, as <em>n</em> gets bigger and bigger, only the largest term, <em>n</em>, matters.</li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>Similarly, a logarithmic running time is <em>O</em>(log <em>n</em>), no matter what the base is, since this is just an approximation of what happens with <em>n</em> is very large.</li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>There are some common running times:
    <ul class="fa-ul">
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><em>O</em>(<em>n</em><sup>2</sup>)</li>
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><em>O</em>(<em>n</em> log <em>n</em>)</li>
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><em>O</em>(<em>n</em>)
        <ul class="fa-ul">
          <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>(linear search)</li>
        </ul>
      </li>
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><em>O</em>(log <em>n</em>)
        <ul class="fa-ul">
          <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>(binary search)</li>
        </ul>
      </li>
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><em>O</em>(1)</li>
    </ul>
  </li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>Computer scientists might also use big Œ©, big Omega notation, which is the lower bound of number of steps for our algorithm. (Big <em>O</em> is the upper bound of number of steps, or the worst case, and typically what we care about more.) With linear search, for example, the worst case is <em>n</em> steps, but the best case is 1 step since our item might happen to be the first item we check. The best case for binary search, too, is 1 since our item might be in the middle of the array.</li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>And we have a similar set of the most common big Œ© running times:
    <ul class="fa-ul">
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>Œ©(<em>n</em><sup>2</sup>)</li>
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>Œ©(<em>n</em> log <em>n</em>)</li>
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>Œ©(<em>n</em>)
        <ul class="fa-ul">
          <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>(counting the number of items)</li>
        </ul>
      </li>
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>Œ©(log <em>n</em>)</li>
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>Œ©(1)
        <ul class="fa-ul">
          <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>(linear search, binary search)</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="linear-search"><a data-id="" href="https://cs50.harvard.edu/college/notes/3/#linear-search">Linear search</a></h2>

<ul class="fa-ul">
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>Let‚Äôs take a look at <code class="highlighter-rouge">numbers.c</code>:
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;cs50.h&gt;
#include &lt;stdio.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// An array of numbers</span>
    <span class="kt">int</span> <span class="n">numbers</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">42</span><span class="p">};</span>

    <span class="c1">// Search for 50</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">50</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"Found</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Not found</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <ul class="fa-ul">
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>Here we initialize an array with some values, and we check the items in the array one at a time, in order.</li>
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>And in each case, depending on whether the value was found or not, we can return an exit code of either 0 (for success) or 1 (for failure).</li>
    </ul>
  </li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>We can do the same for names:
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;cs50.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// An array of names</span>
    <span class="n">string</span> <span class="n">names</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="s">"EMMA"</span><span class="p">,</span> <span class="s">"RODRIGO"</span><span class="p">,</span> <span class="s">"BRIAN"</span><span class="p">,</span> <span class="s">"DAVID"</span><span class="p">};</span>

    <span class="c1">// Search for EMMA</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">names</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="s">"EMMA"</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"Found</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Not found</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <ul class="fa-ul">
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>We can‚Äôt compare strings directly, since they‚Äôre not a simple data type but rather an array of many characters, and we need to compare them differently. Luckily, the <code class="highlighter-rouge">string</code> library has a <code class="highlighter-rouge">strcmp</code> function which compares strings for us and returns <code class="highlighter-rouge">0</code> if they‚Äôre the same, so we can use that.</li>
    </ul>
  </li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>Let‚Äôs try to implement a phone book with the same ideas:
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;cs50.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">string</span> <span class="n">names</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="s">"EMMA"</span><span class="p">,</span> <span class="s">"RODRIGO"</span><span class="p">,</span> <span class="s">"BRIAN"</span><span class="p">,</span> <span class="s">"DAVID"</span><span class="p">};</span>
    <span class="n">string</span> <span class="n">numbers</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="s">"617‚Äì555‚Äì0100"</span><span class="p">,</span> <span class="s">"617‚Äì555‚Äì0101"</span><span class="p">,</span> <span class="s">"617‚Äì555‚Äì0102"</span><span class="p">,</span> <span class="s">"617‚Äì555‚Äì0103"</span><span class="p">};</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">names</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="s">"EMMA"</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"Found %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Not found</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <ul class="fa-ul">
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>We‚Äôll use strings for phone numbers, since they might include formatting or be too long for a number.</li>
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>Now, if the name at a certain index in the <code class="highlighter-rouge">names</code> array matches who we‚Äôre looking for, we‚Äôll return the phone number in the <code class="highlighter-rouge">numbers</code> array, at the same index. But that means we need to particularly careful to make sure that each number corresponds to the name at each index, especially if we add or remove names and numbers.</li>
    </ul>
  </li>
</ul>

<h2 id="structs"><a data-id="" href="https://cs50.harvard.edu/college/notes/3/#structs">Structs</a></h2>

<ul class="fa-ul">
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>It turns out that we can make our own custom data types called <strong>structs</strong>:
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;cs50.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
</span>
<span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
    <span class="n">string</span> <span class="n">name</span><span class="p">;</span>
    <span class="n">string</span> <span class="n">number</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">person</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">person</span> <span class="n">people</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>

    <span class="n">people</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">name</span> <span class="o">=</span> <span class="s">"EMMA"</span><span class="p">;</span>
    <span class="n">people</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">number</span> <span class="o">=</span> <span class="s">"617‚Äì555‚Äì0100"</span><span class="p">;</span>

    <span class="n">people</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">name</span> <span class="o">=</span> <span class="s">"RODRIGO"</span><span class="p">;</span>
    <span class="n">people</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">number</span> <span class="o">=</span> <span class="s">"617‚Äì555‚Äì0101"</span><span class="p">;</span>

    <span class="n">people</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">name</span> <span class="o">=</span> <span class="s">"BRIAN"</span><span class="p">;</span>
    <span class="n">people</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">number</span> <span class="o">=</span> <span class="s">"617‚Äì555‚Äì0102"</span><span class="p">;</span>

    <span class="n">people</span><span class="p">[</span><span class="mi">3</span><span class="p">].</span><span class="n">name</span> <span class="o">=</span> <span class="s">"DAVID"</span><span class="p">;</span>
    <span class="n">people</span><span class="p">[</span><span class="mi">3</span><span class="p">].</span><span class="n">number</span> <span class="o">=</span> <span class="s">"617‚Äì555‚Äì0103"</span><span class="p">;</span>

    <span class="c1">// Search for EMMA</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">people</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">,</span> <span class="s">"EMMA"</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"Found %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">people</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">number</span><span class="p">);</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Not found</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <ul class="fa-ul">
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>We can think of structs as containers, inside of which are multiple other data types.</li>
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>Here, we create our own type with a struct called <code class="highlighter-rouge">person</code>, which will have a <code class="highlighter-rouge">string</code> called <code class="highlighter-rouge">name</code> and a <code class="highlighter-rouge">string</code> called <code class="highlighter-rouge">number</code>. Then, we can create an array of these struct types and initialize the values inside each of them, using a new syntax, <code class="highlighter-rouge">.</code>, to access the properties of each <code class="highlighter-rouge">person</code>.</li>
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>In our loop, we can now be more certain that the <code class="highlighter-rouge">number</code> corresponds to the <code class="highlighter-rouge">name</code> since they are from the same <code class="highlighter-rouge">person</code> element.</li>
    </ul>
  </li>
</ul>

<h2 id="sorting"><a data-id="" href="https://cs50.harvard.edu/college/notes/3/#sorting">Sorting</a></h2>

<ul class="fa-ul">
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>If our input is an unsorted list of numbers, there are many algorithms we could use to produce an output of a sorted list.</li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>With eight volunteers on the stage with the following numbers, we might consider swapping pairs of numbers next to each other as a first step.</li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>Our volunteers start in the following random order:
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>6 3 8 5 2 7 4 1
</code></pre></div>    </div>
  </li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>We look at the first two numbers, and swap them so they are in order:
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>6 3 8 5 2 7 4 1
‚Äì ‚Äì
3 6 8 5 2 7 4 1
</code></pre></div>    </div>
  </li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>The next pair, <code class="highlighter-rouge">6</code> and <code class="highlighter-rouge">8</code>, are in order, so we don‚Äôt need to swap them.</li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>The next pair, <code class="highlighter-rouge">8</code> and <code class="highlighter-rouge">5</code>, need to be swapped:
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>3 6 8 5 2 7 4 1
    ‚Äì ‚Äì
3 6 5 8 2 7 4 1
</code></pre></div>    </div>
  </li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>We continue until we reach the end of the list:
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>3 6 5 2 8 7 4 1
        ‚Äì ‚Äì
3 6 5 2 7 8 4 1
          ‚Äì ‚Äì
3 6 5 2 7 4 8 1
            ‚Äì ‚Äì
3 6 5 2 7 4 1 8
</code></pre></div>    </div>
  </li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>Our list isn‚Äôt sorted yet, but we‚Äôre slightly closer to the solution because the biggest value, <code class="highlighter-rouge">8</code>, has been shifted all the way to the right.</li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>We repeat this with another pass through the list:
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>3 6 5 2 7 4 1 8
‚Äì ‚Äì
3 6 5 2 7 4 1 8
  ‚Äì ‚Äì
3 5 6 2 7 4 1 8
    ‚Äì ‚Äì
3 5 2 6 7 4 1 8
      ‚Äì ‚Äì
3 5 2 6 7 4 1 8
        ‚Äì ‚Äì
3 5 2 6 4 7 1 8
            ‚Äì ‚Äì
3 5 2 6 4 1 7 8
</code></pre></div>    </div>
    <ul class="fa-ul">
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>Note that we didn‚Äôt need to swap the 3 and 6, or the 6 and 7.</li>
    </ul>
  </li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>Now, the next biggest value, <code class="highlighter-rouge">7</code>, moved all the way to the right. If we repeat this, more and more of the list becomes sorted, and pretty quickly we have a fully sorted list.</li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>This algorithm is called <strong>bubble sort</strong>, where large values ‚Äúbubble‚Äù to the right. The pseudocode for this might look like:
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Repeat n‚Äì1 times
    For i from 0 to n‚Äì2
        If i'th and i+1'th elements out of order
            Swap them
</code></pre></div>    </div>
    <ul class="fa-ul">
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>Since we are comparing the <code class="highlighter-rouge">i'th</code> and <code class="highlighter-rouge">i+1'th</code> element, we only need to go up to <em>n</em> ‚Äì 2 for <code class="highlighter-rouge">i</code>. Then, we swap the two elements if they‚Äôre out of order.</li>
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>And we can stop after we‚Äôve made <em>n</em> ‚Äì 1 passes, since we know the largest n‚Äì1 elements will have bubbled to the right.</li>
    </ul>
  </li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>We have <em>n</em> ‚Äì 2 steps for the inner loop, and <em>n</em> ‚Äì 1 loops, so we get <em>n</em><sup>2</sup> ‚Äì 3<em>n</em> + 2 steps total. But the largest factor, or dominant term, is <em>n</em><sup>2</sup>, as <code class="highlighter-rouge">n</code> gets larger and larger, so we can say that bubble sort is <em>O</em>(<em>n</em><sup>2</sup>).</li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>We‚Äôve seen running times like the following, and so even though binary search is much faster than linear search, it might not be worth the one‚Äìtime cost of sorting the list first, unless we do lots of searches over time:
    <ul class="fa-ul">
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><em>O</em>(<em>n</em><sup>2</sup>)
        <ul class="fa-ul">
          <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>bubble sort</li>
        </ul>
      </li>
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><em>O</em>(<em>n</em> log <em>n</em>)</li>
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><em>O</em>(<em>n</em>)
        <ul class="fa-ul">
          <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>linear search</li>
        </ul>
      </li>
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><em>O</em>(log <em>n</em>)
        <ul class="fa-ul">
          <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>binary search</li>
        </ul>
      </li>
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><em>O</em>(1)</li>
    </ul>
  </li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>And Œ© for bubble sort is still <em>n</em><sup>2</sup>, since we still check each pair of elements for <em>n</em> ‚Äì 1 passes.</li>
</ul>

<h2 id="selection-sort"><a data-id="" href="https://cs50.harvard.edu/college/notes/3/#selection-sort">Selection sort</a></h2>

<ul class="fa-ul">
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>We can take another approach with the same set of numbers:
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>6 3 8 5 2 7 4 1
</code></pre></div>    </div>
  </li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>First, we‚Äôll look at each number, and remember the smallest one we‚Äôve seen. Then, we can swap it with the first number in our list, since we know it‚Äôs the smallest:
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>6 3 8 5 2 7 4 1
‚Äì             ‚Äì
1 3 8 5 2 7 4 6
</code></pre></div>    </div>
  </li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>Now we know at least the first element of our list is in the right place, so we can look for the smallest element among the rest, and swap it with the next unsorted element (now the second element):
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1 3 8 5 2 7 4 6
  ‚Äì     ‚Äì
1 2 8 5 3 7 4 6
</code></pre></div>    </div>
  </li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>We can repeat this over and over, until we have a sorted list.</li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>This algorithm is called <strong>selection sort</strong>, and we might write pseudocode like this:
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>For i from 0 to n‚Äì1
    Find smallest item between i'th item and last item
    Swap smallest item with i'th item
</code></pre></div>    </div>
  </li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>With big <em>O</em> notation, we still have running time of <em>O</em>(<em>n</em><sup>2</sup>), since we were looking at roughly all <em>n</em> elements to find the smallest, and making <em>n</em> passes to sort all the elements.</li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>More formally, we can use some formulas to show that the biggest factor is indeed <em>n</em><sup>2</sup>:
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>n + (n ‚Äì 1) + (n ‚Äì 2) + ... + 1
n(n + 1)/2
(n^2 + n)/2
n^2/2 + n/2
O(n^2)
</code></pre></div>    </div>
  </li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>So it turns out that selection sort is fundamentally about the same as bubble sort in running time:
    <ul class="fa-ul">
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><em>O</em>(<em>n</em><sup>2</sup>)
        <ul class="fa-ul">
          <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>bubble sort, selection sort</li>
        </ul>
      </li>
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><em>O</em>(<em>n</em> log <em>n</em>)</li>
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><em>O</em>(<em>n</em>)
        <ul class="fa-ul">
          <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>linear search</li>
        </ul>
      </li>
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><em>O</em>(log <em>n</em>)
        <ul class="fa-ul">
          <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>binary search</li>
        </ul>
      </li>
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><em>O</em>(1)</li>
    </ul>
  </li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>The best case, Œ©, is also <em>n</em><sup>2</sup>.</li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>We can go back to bubble sort and change its algorithm to be something like this, which will allow us to stop early if all the elements are sorted:
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Repeat until no swaps
    For i from 0 to n‚Äì2
        If i'th and i+1'th elements out of order
            Swap them
</code></pre></div>    </div>
    <ul class="fa-ul">
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>Now, we only need to look at each element once, so the best case is now Œ©(<em>n</em>):
        <ul class="fa-ul">
          <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>Œ©(<em>n</em><sup>2</sup>)
            <ul class="fa-ul">
              <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>selection sort</li>
            </ul>
          </li>
          <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>Œ©(<em>n</em> log <em>n</em>)</li>
          <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>Œ©(<em>n</em>)
            <ul class="fa-ul">
              <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>bubble sort</li>
            </ul>
          </li>
          <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>Œ©(log <em>n</em>)</li>
          <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>Œ©(1)
            <ul class="fa-ul">
              <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>linear search, binary search</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>We look at a visualization online <a href="https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html">comparing sorting algorithms</a> with animations for how the elements move within arrays for both bubble sort and insertion sort.</li>
</ul>

<h2 id="recursion"><a data-id="" href="https://cs50.harvard.edu/college/notes/3/#recursion">Recursion</a></h2>

<ul class="fa-ul">
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>Recall that in week 0, we had pseudocode for finding a name in a phone book, where we had lines telling us to ‚Äúgo back‚Äù and repeat some steps:
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1  Pick up phone book
2  Open to middle of phone book
3  Look at page
4  If Smith is on page
5      Call Mike
6  Else if Smith is earlier in book
7      Open to middle of left half of book
8      **Go back to line 3**
9  Else if Smith is later in book
10     Open to middle of right half of book
11     **Go back to line 3**
12 Else
13     Quit
</code></pre></div>    </div>
  </li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>We could instead just repeat our entire algorithm on the half of the book we have left:
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1  Pick up phone book
2  Open to middle of phone book
3  Look at page
4  If Smith is on page
5      Call Mike
6  Else if Smith is earlier in book
7      **Search left half of book**
8
9  Else if Smith is later in book
10     **Search right half of book**
11
12 Else
13     Quit
</code></pre></div>    </div>
    <ul class="fa-ul">
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>This seems like a cyclical process that will never end, but we‚Äôre actually dividing the problem in half each time, and stopping once there‚Äôs no more book left.</li>
    </ul>
  </li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><strong>Recursion</strong> occurs when a function or algorithm refers to itself, as in the new pseudocode above.</li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>In week 1, too, we implemented a ‚Äúpyramid‚Äù of blocks in the following shape:
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#
##
###
####
</code></pre></div>    </div>
    <ul class="fa-ul">
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>And we might have had iterative code like this:
        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;cs50.h&gt;
#include &lt;stdio.h&gt;
</span>
<span class="kt">void</span> <span class="nf">draw</span><span class="p">(</span><span class="kt">int</span> <span class="n">h</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Get height of pyramid</span>
    <span class="kt">int</span> <span class="n">height</span> <span class="o">=</span> <span class="n">get_int</span><span class="p">(</span><span class="s">"Height: "</span><span class="p">);</span>

    <span class="c1">// Draw pyramid</span>
    <span class="n">draw</span><span class="p">(</span><span class="n">height</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">draw</span><span class="p">(</span><span class="kt">int</span> <span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Draw pyramid of height h</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">h</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"#"</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>        </div>
        <ul class="fa-ul">
          <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>Here, we use <code class="highlighter-rouge">for</code> loops to print each block in each row.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>But notice that a pyramid of height 4 is actually a pyramid of height 3, with an extra row of 4 blocks added on. And a pyramid of height 3 is a pyramid of height 2, with an extra row of 3 blocks. A pyramid of height 2 is a pyramid of height 1, with an extra row of 2 blocks. And finally, a pyramid of height 1 is just a pyramid of height 0, or nothing, with another row of a single block added on.</li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>With this idea in mind, we can write:
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;cs50.h&gt;
#include &lt;stdio.h&gt;
</span>
<span class="kt">void</span> <span class="nf">draw</span><span class="p">(</span><span class="kt">int</span> <span class="n">h</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Get height of pyramid</span>
    <span class="kt">int</span> <span class="n">height</span> <span class="o">=</span> <span class="n">get_int</span><span class="p">(</span><span class="s">"Height: "</span><span class="p">);</span>

    <span class="c1">// Draw pyramid</span>
    <span class="n">draw</span><span class="p">(</span><span class="n">height</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">draw</span><span class="p">(</span><span class="kt">int</span> <span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// If nothing to draw</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">h</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Draw pyramid of height h ‚Äì 1</span>
    <span class="n">draw</span><span class="p">(</span><span class="n">h</span> <span class="err">‚Äì</span> <span class="mi">1</span><span class="p">);</span>

    <span class="c1">// Draw one more row of width h</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">h</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"#"</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <ul class="fa-ul">
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>Now, our <code class="highlighter-rouge">draw</code> function first calls itself <strong>recursively</strong>, drawing a pyramid of height <code class="highlighter-rouge">h ‚Äì 1</code>. But even before that, we need to stop if <code class="highlighter-rouge">h</code> is 0, since there won‚Äôt be anything left to drawn.</li>
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>After, we draw the next row, or a row of width <code class="highlighter-rouge">h</code>.</li>
    </ul>
  </li>
</ul>

<h2 id="merge-sort"><a data-id="" href="https://cs50.harvard.edu/college/notes/3/#merge-sort">Merge sort</a></h2>

<ul class="fa-ul">
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>We can take the idea of recusion to sorting, with another algorithm called merge sort. The pseudocode might look like:
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>If only one item
  Return
Else
    Sort left half of items
    Sort right half of items
    Merge sorted halves
</code></pre></div>    </div>
  </li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>We‚Äôll best see this in practice with an unsorted list:
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>7 4 5 2 6 3 8 1
</code></pre></div>    </div>
  </li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>First, we‚Äôll sort the left half (the first four elements):
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>7 4 5 2 | 6 3 8 1
‚Äì ‚Äì ‚Äì ‚Äì
</code></pre></div>    </div>
  </li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>Well, to sort that, we need to sort the left half of the left half first:
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>7 4 | 5 2 | 6 3 8 1
‚Äì ‚Äì
</code></pre></div>    </div>
  </li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>Now, we have just one item, <code class="highlighter-rouge">7</code>, in the left half, and one item, <code class="highlighter-rouge">4</code>, in the right half. So we‚Äôll merge that together, by taking the smallest item from each list first:
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>‚Äì ‚Äì | 5 2 | 6 3 8 1
4 7
</code></pre></div>    </div>
  </li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>And now we go back to the right half of the left half, and sort it:
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>‚Äì ‚Äì | ‚Äì ‚Äì | 6 3 8 1
4 7 | 2 5
</code></pre></div>    </div>
  </li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>Now, both halves of the left half are sorted, so we can merge the two of them together. We look at the start of each list, and take <code class="highlighter-rouge">2</code> since it‚Äôs smaller than <code class="highlighter-rouge">4</code>. Then, we take <code class="highlighter-rouge">4</code>, since it‚Äôs now the smallest item at the front of both lists. Then, we take <code class="highlighter-rouge">5</code>, and finally, <code class="highlighter-rouge">7</code>, to get:
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>‚Äì ‚Äì ‚Äì ‚Äì | 6 3 8 1
‚Äì ‚Äì ‚Äì ‚Äì
2 4 5 7
</code></pre></div>    </div>
  </li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>We now sort the right half the same way. First, the left half of the right half:
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì | 8 1
‚Äì ‚Äì ‚Äì ‚Äì | 3 6 |
2 4 5 7
</code></pre></div>    </div>
  </li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>Then, the right half of the right half:
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì | ‚Äì ‚Äì
‚Äì ‚Äì ‚Äì ‚Äì | 3 6 | 1 8
2 4 5 7
</code></pre></div>    </div>
  </li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>We can merge the right half together now:
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
2 4 5 7 | 1 3 6 8
</code></pre></div>    </div>
  </li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>And finally, we can merge both halves of the whole list, following the same steps as before. Notice that we don‚Äôt need to check all the elements of each half to find the smallest, since we know that each half is already sorted. Instead, we just take the smallest element of the two at the start of each half:
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
2 4 5 7 | ‚Äì 3 6 8
1
</code></pre></div>    </div>
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
‚Äì 4 5 7 | ‚Äì 3 6 8
1 2
</code></pre></div>    </div>
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
‚Äì 4 5 7 | ‚Äì ‚Äì 6 8
1 2 3
</code></pre></div>    </div>
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
‚Äì ‚Äì 5 7 | ‚Äì ‚Äì 6 8
1 2 3 4
</code></pre></div>    </div>
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
‚Äì ‚Äì ‚Äì 7 | ‚Äì ‚Äì 6 8
1 2 3 4   5
</code></pre></div>    </div>
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
‚Äì ‚Äì ‚Äì 7 | ‚Äì ‚Äì ‚Äì 8
1 2 3 4   5 6
</code></pre></div>    </div>
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì 8
1 2 3 4   5 6 7
</code></pre></div>    </div>
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
‚Äì ‚Äì ‚Äì ‚Äì | ‚Äì ‚Äì ‚Äì ‚Äì
1 2 3 4   5 6 7 8
</code></pre></div>    </div>
  </li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>It took a lot of steps, but it actually took fewer steps than the other algorithms we‚Äôve seen so far. We broke our list in half each time, until we were ‚Äúsorting‚Äù eight lists with one element each:
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>7 | 4 | 5 | 2 | 6 | 3 | 8 | 1
4   7 | 2   5 | 3   6 | 1   8
2   4   5   7 | 1   3   6   8
1   2   3   4   5   6   7   8
</code></pre></div>    </div>
  </li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>Since our algorithm divided the problem in half each time, its running time is logarithmic with <em>O</em>(log <em>n</em>). And after we sorted each half (or half of a half), we needed to merge together all the elements, with <em>n</em> steps since we had to look at each element once.</li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>So our total running time is <em>O</em>(<em>n</em> log <em>n</em>):
    <ul class="fa-ul">
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><em>O</em>(<em>n</em><sup>2</sup>)
        <ul class="fa-ul">
          <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>bubble sort, selection sort</li>
        </ul>
      </li>
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><em>O</em>(<em>n</em> log <em>n</em>)
        <ul class="fa-ul">
          <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>merge sort</li>
        </ul>
      </li>
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><em>O</em>(<em>n</em>)
        <ul class="fa-ul">
          <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>linear search</li>
        </ul>
      </li>
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><em>O</em>(log <em>n</em>)
        <ul class="fa-ul">
          <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>binary search</li>
        </ul>
      </li>
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span><em>O</em>(1)</li>
    </ul>
  </li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>Since log <em>n</em> is greater than 1 but less than <em>n</em>, <em>n</em> log <em>n</em> is in between <em>n</em> (times 1) and <em>n</em><sup>2</sup>.</li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>The best case, Œ©, is still <em>n</em> log <em>n</em>, since we still sort each half first and then merge them together:
    <ul class="fa-ul">
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>Œ©(<em>n</em><sup>2</sup>)
        <ul class="fa-ul">
          <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>selection sort</li>
        </ul>
      </li>
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>Œ©(<em>n</em> log <em>n</em>)
        <ul class="fa-ul">
          <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>merge sort</li>
        </ul>
      </li>
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>Œ©(<em>n</em>)
        <ul class="fa-ul">
          <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>bubble sort</li>
        </ul>
      </li>
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>Œ©(log <em>n</em>)</li>
      <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>Œ©(1)
        <ul class="fa-ul">
          <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>linear search, binary search</li>
        </ul>
      </li>
    </ul>
  </li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>Finally, there is another notation, Œò, Theta, which we use to describe running times of algorithms if the upper bound and lower bound is the same. For example, merge sort has Œò(<em>n</em> log <em>n</em>) since the best and worst case both require the same number of steps. And selection sort has Œò(<em>n</em><sup>2</sup>).</li>
  <li data-marker="*"><span class="fa-li"><i class="fas fa-circle"></i></span>We look at a <a href="https://www.youtube.com/watch?v=ZZuD6iUe3Pc">final visualization</a> of sorting algorithms with a larger number of inputs, running at the same time.</li>
</ul>


                </main>

            </div>

        </div>

    


</body></html>